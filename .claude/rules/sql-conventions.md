---
description: SQL conventions for analytics queries and dbt models
globs:
  - "**/*.sql"
---

# SQL Conventions for Analytics

## Formatting

### CTEs over subqueries
Always use Common Table Expressions (CTEs) instead of nested subqueries. CTEs make queries readable, testable, and composable. Each CTE should do one logical thing.

```sql
-- Good
with

orders as (
    select *
    from {{ ref('stg_orders') }}
),

customers as (
    select *
    from {{ ref('stg_customers') }}
),

final as (
    select
        o.order_id,
        o.order_date,
        c.customer_name
    from orders as o
    left join customers as c
        on o.customer_id = c.customer_id
)

select * from final
```

### Trailing commas
Use trailing commas in SELECT lists. This makes diffs cleaner and reduces merge conflicts.

```sql
select
    user_id,
    created_at,
    email,
```

### Lowercase keywords
All SQL keywords must be lowercase: `select`, `from`, `where`, `join`, `on`, `group by`, `order by`, `with`, `as`, `and`, `or`, `not`, `in`, `case`, `when`, `then`, `else`, `end`, `union`, `all`, `having`, `limit`, `distinct`, `null`, `true`, `false`, `is`, `between`, `like`, `exists`, `cast`, `coalesce`.

### Meaningful aliases
Use short but descriptive aliases. Single-letter aliases are acceptable only when the context is unambiguous (e.g., `o` for orders in a query that is clearly about orders). Prefer readable names over abbreviations.

```sql
-- Good
from orders as o
left join customers as c on o.customer_id = c.customer_id

-- Bad
from orders as a
left join customers as b on a.customer_id = b.customer_id
```

### Indentation and alignment
- Use 4 spaces for indentation (no tabs).
- Each column in a SELECT should be on its own line.
- JOIN conditions go on the line after the JOIN, indented.
- WHERE conditions each go on their own line with `and`/`or` at the start.

## Naming

### snake_case everywhere
All identifiers use `snake_case`: column names, CTE names, model names, macro names.

### Model prefix conventions
Follow the dbt modeling layer conventions:

| Prefix | Layer | Purpose |
|--------|-------|---------|
| `stg_` | Staging | 1:1 with source tables. Renaming, type casting, basic cleanup only. |
| `int_` | Intermediate | Business logic building blocks. Not exposed to end users. |
| `fct_` | Fact | Event or transaction grain tables (immutable). |
| `dim_` | Dimension | Entity or attribute tables (slowly changing). |
| `rpt_` | Report | Pre-aggregated tables for specific dashboards or reports. |
| `mrt_` | Mart | Wide, denormalized tables for a specific business domain. |

### Column naming conventions
- Boolean columns: prefix with `is_` or `has_` (e.g., `is_active`, `has_subscription`).
- Date columns: suffix with `_date` (e.g., `created_date`, `shipped_date`).
- Timestamp columns: suffix with `_at` (e.g., `created_at`, `updated_at`).
- ID columns: suffix with `_id` (e.g., `user_id`, `order_id`).
- Count columns: prefix with `count_` or suffix with `_count` (e.g., `order_count`).
- Amounts/money: suffix with the unit (e.g., `revenue_usd`, `price_cents`).

## Performance

### Filter early
Apply WHERE clauses as early as possible in CTEs. Do not join full tables and then filter -- filter first, then join.

```sql
-- Good: filter in the CTE
with recent_orders as (
    select *
    from {{ ref('stg_orders') }}
    where order_date >= current_date - interval '90 days'
)

-- Bad: filter after joining everything
```

### Avoid SELECT *
Never use `SELECT *` in final models or production queries. Explicitly list the columns you need. `SELECT *` is acceptable only within CTEs that reference a ref or source, as a staging passthrough.

### Use appropriate joins
- Use `left join` as the default unless you have a reason for `inner join`.
- Never use `right join` -- reorder the tables instead.
- Use `cross join` only when intentional (e.g., date spines).
- Always specify the join type explicitly; never use bare `join` (which is implicitly `inner join`).

### Avoid DISTINCT as a fix
If you need `DISTINCT`, investigate why duplicates exist. Usually it means a missing join condition or an incorrect grain. Fix the root cause rather than masking it with DISTINCT.

### Limit sorts in intermediate models
Only use `ORDER BY` in the final SELECT or in window functions. Sorting intermediate CTEs wastes compute.

## Documentation

### Comment complex logic
Add comments explaining *why*, not *what*. The SQL itself shows what; the comment should explain the business reason.

```sql
-- Exclude trial orders that were auto-generated by the onboarding flow.
-- These are not real revenue events and inflate conversion metrics.
where order_type != 'trial_auto'
```

### Include data freshness notes
When a model depends on data that has known latency, document it:

```sql
-- NOTE: payment_events has ~2 hour ingestion lag.
-- This model should not be used for real-time revenue dashboards.
```

### Model-level documentation
Every model should have a YAML entry with:
- A `description` explaining its purpose and grain.
- Column-level descriptions for all non-obvious columns.
- The `meta` tag indicating the data owner or team.

## Testing

### Required tests for every model
Every model must have, at minimum:
1. A `unique` test on the primary key.
2. A `not_null` test on the primary key.

```yaml
models:
  - name: fct_orders
    description: One row per order. Grain is order_id.
    columns:
      - name: order_id
        description: Primary key.
        tests:
          - unique
          - not_null
```

### Additional recommended tests
- `accepted_values` on status/type columns.
- `relationships` to validate foreign keys.
- Row-count anomaly tests (using dbt-utils or elementary) on critical models.
- Freshness tests on source tables via `dbt source freshness`.

### Test naming
Custom test names should describe what they validate: `assert_revenue_is_positive`, `assert_no_future_dates`.
